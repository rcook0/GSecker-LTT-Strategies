//@version=5
strategy("GSecker Master Strategy — 7-in-1 (enhanced 180PC w/ ATR ZigZag)",
  overlay=true, calc_on_order_fills=true, calc_on_every_tick=true,
  initial_capital=10000, commission_type=strategy.commission.percent, commission_value=0.0,
  process_orders_on_close=true, default_qty_type=strategy.fixed, pyramiding=0)

// ===== Selector & globals =====
mode = input.string("All", "Strategy Selector",
     options=["180 PC","Bollinger Bounce","Breakfast","Pip River","Pip Runner","Volatility Reversal","T-Wave","All"])
acctSize = input.float(10000, "Account Size", step=1)
riskPct  = input.float(1.0, "Risk % per Trade", minval=0.01, step=0.01)
offsetPips = input.float(1.0, "Entry offset (pips/points)", step=0.1)
var float TICK = syminfo.mintick
toff = offsetPips * TICK
riskAmt() => acctSize * (riskPct/100.0)
qtyFromRisk(stopDist) => math.max(0.0, riskAmt() / math.max(stopDist, TICK))

enterWithStops(id, dir, entry, sl, rr) =>
    sd = math.abs(entry - sl)
    qty = qtyFromRisk(sd)
    if dir == "L"
        strategy.order(id, strategy.long, qty=qty, stop=entry, comment=id)
        strategy.exit(id+" TP/SL", id, stop=sl, limit=entry + rr*sd)
    if dir == "S"
        strategy.order(id, strategy.short, qty=qty, stop=entry, comment=id)
        strategy.exit(id+" TP/SL", id, stop=sl, limit=entry - rr*sd)

// Symbol restriction (optional)
restrictSymbols = input.bool(false, "Restrict symbols (XAU, BTC, GBPJPY)")
allowXAU = input.bool(true, "XAUUSD")
allowBTC = input.bool(true, "BTCUSD/USDT")
allowGJ  = input.bool(true, "GBPJPY")
symOK = not restrictSymbols or ( (allowXAU and str.contains(syminfo.ticker, "XAU"))
      or (allowBTC and (str.contains(syminfo.ticker,"BTC") or str.contains(syminfo.ticker,"BTCUSDT")))
      or (allowGJ  and str.contains(syminfo.ticker,"GBPJPY")) )

// ---------------------------------------------------------------------------
// ===================== Enhanced 180 PC w/ ATR ZigZag ========================
// ---------------------------------------------------------------------------
// Inputs
use180 = (mode=="180 PC") or (mode=="All")
sigTF_180 = input.timeframe("240","180PC: Signal TF (run H4 for H4 signals)")
emaFast_180 = input.int(8, "180PC EMA fast")
emaSlow_180 = input.int(20, "180PC EMA slow")
zzATRmult = input.float(2.5, "180PC ZigZag ATR multiplier (N)", step=0.1) // ATR(14) * N
zzATRlen  = 14
zzMinSwings = input.int(4, "180PC ZigZag swings to store", minval=4)
zzRequireCycles = input.int(2, "180PC Required same-direction cycles", minval=1)
rr_180 = input.float(1.0, "180PC Reward:Risk", minval=0.1)
requireWeeklyForD1 = input.bool(true, "180PC: require weekly agreement for D1 signals")

// Helper: HTF EMA alignment (D1 + sigTF)
emaD_fast = request.security(syminfo.tickerid, "D", ta.ema(close, emaFast_180))
emaD_slow = request.security(syminfo.tickerid, "D", ta.ema(close, emaSlow_180))
d1_long = emaD_fast > emaD_slow
d1_short = emaD_fast < emaD_slow

emaSig_fast = request.security(syminfo.tickerid, sigTF_180, ta.ema(close, emaFast_180))
emaSig_slow = request.security(syminfo.tickerid, sigTF_180, ta.ema(close, emaSlow_180))
sig_long = emaSig_fast > emaSig_slow
sig_short = emaSig_fast < emaSig_slow

// Daily candle bias
dPrevBull = request.security(syminfo.tickerid, "D", close[1] > open[1])
dPrevBear = request.security(syminfo.tickerid, "D", close[1] < open[1])

// Weekly check (for D1 signals)
emaW_fast = request.security(syminfo.tickerid, "W", ta.ema(close, emaFast_180))
emaW_slow = request.security(syminfo.tickerid, "W", ta.ema(close, emaSlow_180))
w_long = emaW_fast > emaW_slow
w_short = emaW_fast < emaW_slow

// ZigZag (ATR-based) - computed on current chart timeframe. To be most faithful run on same TF as sigTF_180.
var float zz_threshold = na
atr_local = ta.atr(zzATRlen)
zz_threshold := atr_local * zzATRmult

// Swing state
var float lastSwingPrice = na
var int lastSwingType = 0  // 1 = high, -1 = low
var float swingPrices[] = array.new_float()
var int   swingTypes[]  = array.new_int()
var int   swingBars[]   = array.new_int()

// initialize on first bar
if barstate.isfirst
    lastSwingPrice := close
    lastSwingType := 0

// detect swings
swingHigh = false
swingLow = false
if (high - lastSwingPrice) >= zz_threshold and (lastSwingType != 1)
    swingHigh := true
if (lastSwingPrice - low) >= zz_threshold and (lastSwingType != -1)
    swingLow := true

if swingHigh
    // register swing high
    lastSwingPrice := high
    lastSwingType := 1
    array.unshift(swingPrices, lastSwingPrice)
    array.unshift(swingTypes, lastSwingType)
    array.unshift(swingBars, bar_index)
    // trim
    while array.size(swingPrices) > zzMinSwings
        array.pop(swingPrices)
        array.pop(swingTypes)
        array.pop(swingBars)
if swingLow
    // register swing low
    lastSwingPrice := low
    lastSwingType := -1
    array.unshift(swingPrices, lastSwingPrice)
    array.unshift(swingTypes, lastSwingType)
    array.unshift(swingBars, bar_index)
    while array.size(swingPrices) > zzMinSwings
        array.pop(swingPrices)
        array.pop(swingTypes)
        array.pop(swingBars)

// classify recent swings as HH/HL/LH/LL and compute 'cycles' (conservative approach)
// We'll compute consecutive same-direction swing confirmations: find the last two swing highs (or lows)
// and check if they are higher/lower than the previous corresponding swings.
f_count_up_cycles() =>
    upCycles = 0
    // need at least 4 swings to count two cycles (low->high->low->high)
    if array.size(swingPrices) >= 4
        // build arrays of last 4 swings
        sTypes = array.slice(swingTypes, 0, 4)
        sPrices= array.slice(swingPrices, 0, 4)
        // check pattern of low/high alternation and increasing highs & lows
        // find highs indexes
        highs = array.new_float()
        lows  = array.new_float()
        for i=0 to array.size(sTypes)-1
            t = array.get(sTypes, i)
            p = array.get(sPrices, i)
            if t == 1
                array.push(highs, p)
            else
                array.push(lows, p)
        if array.size(highs) >= 2 and array.size(lows) >= 2
            // compare recent two highs & lows
            h1 = array.get(highs, 1) // earlier
            h2 = array.get(highs, 0) // later
            l1 = array.get(lows, 1)
            l2 = array.get(lows, 0)
            if (h2 > h1) and (l2 > l1)
                upCycles := 2
    upCycles

f_count_down_cycles() =>
    dnCycles = 0
    if array.size(swingPrices) >= 4
        sTypes = array.slice(swingTypes, 0, 4)
        sPrices= array.slice(swingPrices, 0, 4)
        highs = array.new_float()
        lows  = array.new_float()
        for i=0 to array.size(sTypes)-1
            t = array.get(sTypes, i)
            p = array.get(sPrices, i)
            if t == 1
                array.push(highs, p)
            else
                array.push(lows, p)
        if array.size(highs) >= 2 and array.size(lows) >= 2
            h1 = array.get(highs, 1)
            h2 = array.get(highs, 0)
            l1 = array.get(lows, 1)
            l2 = array.get(lows, 0)
            if (h2 < h1) and (l2 < l1)
                dnCycles := 2
    dnCycles

upCycles = f_count_up_cycles()
dnCycles = f_count_down_cycles()

// determine if trend cycles satisfied
sigCycleUpOk = upCycles >= zzRequireCycles
sigCycleDnOk = dnCycles >= zzRequireCycles

// Now combine conditions for H4 / D1 signals
// We'll assume script runs on the sigTF_180 timeframe for best fidelity. If running on other TFs, HTF confirmations are still checked above.
isSigTF = timeframe.period == sigTF_180

// Define ring low/high entry criteria preserved (but 180PC now requires cycles+EMA alignment)
ringLow = (low[1] < low[2]) and (high[1] < high[2])
ringHigh = (high[1] > high[2]) and (low[1] > low[2])

// Entry permission: require D1 + SigTF EMA agreement, previous daily candle bias, and ZigZag cycles
allowLong180 = (d1_long and sig_long) and sigCycleUpOk and dPrevBull
allowShort180 = (d1_short and sig_short) and sigCycleDnOk and dPrevBear

// For D1 signals (if you run the script on D1), optionally require Weekly agreement
if timeframe.period == "D" and requireWeeklyForD1
    allowLong180 := allowLong180 and w_long
    allowShort180 := allowShort180 and w_short

// Trigger entries (only one position at a time)
if use180 and symOK and strategy.position_size == 0
    if ringLow and allowLong180
        e = high[1] + toff
        sl = low[1]  - toff
        enterWithStops("180PC L", "L", e, sl, rr_180)
    if ringHigh and allowShort180
        e = low[1]  - toff
        sl = high[1] + toff
        enterWithStops("180PC S", "S", e, sl, rr_180)

// ---------------------------------------------------------------------------
// ========================= other strategies (unchanged) =====================
// ---------------------------------------------------------------------------
// For brevity, other modules (Bollinger, Breakfast, Pip River, Pip Runner, VolRev, T-Wave)
// are included as before (kept essentially same as prior master strategy). 
// For space, they are included verbatim from the earlier master script (omitted here)
// — implement them the same as previous full master strategy you already received.
// In your TradingView paste use the previous versions of those blocks (they remain unchanged).
// ---------------------------------------------------------------------------

// Alerts for 180PC (and others left as before)
alertcondition(use180 and ringLow and allowLong180,  "180PC Long",  "180PC Long candidate on {{ticker}}")
alertcondition(use180 and ringHigh and allowShort180, "180PC Short", "180PC Short candidate on {{ticker}}")

// Notes:
// • ZigZag uses ATR(14) * N on the CURRENT CHART TF. For best results run the script on H4 when using H4 signals,
//   or on D1 when using D1 signals. Cross-timeframe ZigZag is intentionally not auto-computed here to avoid repaint complexity.
// • D1 weekly agreement is optional and applied to D1 signals.
// • The rest of the strategies (BB, Breakfast, River, Runner, VolRev, T-Wave) remain available in the selector.
//   If you want the full combined file pasted here end-to-end, I can paste the full other blocks again (they were unchanged).
